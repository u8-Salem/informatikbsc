# Assignment 3 

## Aufgabe 1

### a 

Die beiden Technicken schließen sich gegenseitig nicht aus. SCRUM ist eine Management-Hülle, während XP die genaue Umsetzung und Prinzipien des Entwickeln beschreibt. Daher sind diese gut kombinierbar und werden in der Praxis auch oft kombiniert. 

### b 

- was gemacht wurde
- was gemacht werden soll 
- welche Probleme es gegeben hat

### c 

- Product Owner/Kunde: hauptverantwortlich für das Projekt. Erstellt User Stories und sortiert sie nach Priorität.
- Scrum Master: Moderiert das tägliche Meeting. Hilft Probleme zu identifizieren und hilft diese zu beheben. 
- Scrum Team: Entwicklen das Produkt. Geben Rückmeldung im daily scrum.

## Aufgabe 2

YAGNI - "you arent gonna need it"
### a

ein Prinzip des extreme Programming. besagt dass keine Funktionalität implementiert werden soll, die nicht unmittelbar benötigt wird. 

### b 

YAGNI hilft bei dem Ziel Einfachheit anzustreben. Je weniger man "vorraus denkt" desto weniger kann man mit seiner Vorraussicht auch daneben liegen und das Produkt unnötig verkomplizieren. 

## Aufgabe 3

- Pair Programming: 
Beim Pair Programming arbeiten zwei Entwickler gleichzeitig an einer Aufgabe. Dabei ist einer der aktive Entwickler der den Code schreibt, der andere ließt währenddessen mit und reviewed den Code sofort. Dies ist effektiv, da so ein direktes Feedback zu besteht, was hilft Fehler und Bugs früh zu identifizieren. Außerdem können sich die Entwickler über verschiede Ansätze austauschne und eventuelle Wissenlücken ergänzen. Gerade für junior Entwickler ist dies besonders sinnvoll, da sie schnell und direkt von erfahreneren Entwicklern lernen können. 

## Aufgabe 4 

**Symmetry of Ignorance**
### a 

Symmetry of Ignorance beschreibt, dass sowohl auf Seite der Entwickler, als auch auf Seite des Kunden Unverständniss für die andere Seite besteht. 

### b 

dies beruht auf fachlicher Unwissenheit der beiden Seiten für die jeweils andere. So können Kunden bspw. nicht einschätzen, was Software leisten kann oder was ein "einfaches" und was ein "schweres" Problem ist. Die Entwickler wissen auf der anderen Seite nicht wie das genaue Geschäftsmodell des Kunden ist und was genau der Kunde von seiner Software möchte. 